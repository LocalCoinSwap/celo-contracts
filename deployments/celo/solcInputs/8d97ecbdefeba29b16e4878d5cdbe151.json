{
  "language": "Solidity",
  "sources": {
    "contracts/libs/Address.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{ value: amount }(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    return _functionCallWithValue(target, data, value, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{ value: weiValue }(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // solhint-disable-next-line max-line-length\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) - value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n"
    },
    "contracts/libs/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  // USDC gasless send\n  function transferWithAuthorization(\n    address from,\n    address to,\n    uint256 value,\n    uint256 validAfter,\n    uint256 validBefore,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n"
    },
    "contracts/OnChainEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libs/SafeERC20.sol\";\nimport \"./libs/IERC20.sol\";\n\ncontract OnChainEscrow {\n  using SafeERC20 for IERC20;\n\n  /***********************\n    +       Globals        +\n    ***********************/\n\n  address public arbitrator;\n  address public owner;\n  address public relayer;\n\n  struct Escrow {\n    bool exists;\n    uint128 relayerGasSpent;\n    address tokenContract;\n  }\n\n  mapping(bytes32 => Escrow) public escrows;\n  mapping(address => uint256) public collectedFees;\n\n  /***********************\n    +     Instructions     +\n    ***********************/\n\n  uint8 constant private RELEASE_ESCROW = 0x01;\n  uint8 constant private BUYER_CANCELS = 0x02;\n  uint8 constant private RESOLVE_DISPUTE = 0x03;\n\n  /***********************\n    +       Events        +\n    ***********************/\n\n  event Created(bytes32 tradeHash);\n  event Cancelled(bytes32 tradeHash, uint128 relayerGasSpent);\n  event Released(bytes32 tradeHash, uint128 relayerGasSpent);\n  event DisputeResolved(bytes32 tradeHash, uint128 relayerGasSpent);\n\n  /***********************\n    +     Constructor      +\n    ***********************/\n\n  constructor(address initialAddress) {\n    owner = initialAddress;\n    arbitrator = initialAddress;\n    relayer = initialAddress;\n  }\n\n  /***********************\n    +     Open Escrow     +\n    ***********************/\n\n  function createEscrow(\n    bytes32 _tradeHash,\n    uint256 _value,\n    uint8 _v, // Signature value\n    bytes32 _r, // Signature value\n    bytes32 _s // Signature value\n  ) external payable {\n    require(!escrows[_tradeHash].exists, \"Trade already exists\");\n    require(_value > 1, \"Escrow value too small\");\n    bytes32 _invitationHash = keccak256(abi.encodePacked(_tradeHash));\n    require(\n      recoverAddress(_invitationHash, _v, _r, _s) == relayer,\n      \"Signature not from relayer\"\n    );\n\n    IERC20(relayer).safeTransferFrom(msg.sender, address(this), _value);\n\n    escrows[_tradeHash] = Escrow(true, 0, relayer);\n    emit Created(_tradeHash);\n  }\n\n  function relayEscrow(\n    bytes32 _tradeHash,\n    address _currency,\n    uint256 _value,\n    uint8 _v, // Signature value for trade invitation by LocalCoinSwap\n    bytes32 _r, // Signature value for trade invitation by LocalCoinSwap\n    bytes32 _s, // Signature value for trade invitation by LocalCoinSwp\n    bytes32 _nonce, // Random nonce used for Gasless send\n    uint8 _v_gasless, // Signature value for GasLess send\n    bytes32 _r_gasless, // Signature value for GasLess send\n    bytes32 _s_gasless // Signature value for GasLess send\n  ) external payable {\n    require(\n      !escrows[_tradeHash].exists,\n      \"Trade already exists\"\n    );\n    bytes32 _invitationHash = keccak256(abi.encodePacked(_tradeHash));\n    require(_value > 1, \"Escrow value too small\"); // Check escrow value is greater than minimum value\n    require(\n      recoverAddress(_invitationHash, _v, _r, _s) == relayer,\n      \"Signature not from relayer\"\n    );\n\n    // Perform gasless send from seller to contract\n    IERC20(_currency).transferWithAuthorization(\n      msg.sender,\n      address(this),\n      _value,\n      0,\n      2**256 - 1, // MAX INT\n      _nonce,\n      _v_gasless,\n      _r_gasless,\n      _s_gasless\n    );\n\n    escrows[_tradeHash] = Escrow(true, 0, _currency);\n    emit Created(_tradeHash);\n  }\n\n  /***********************\n    +   Complete Escrow    +\n    ***********************/\n\n  function release(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee\n  ) external returns (bool) {\n    require(msg.sender == _seller, \"Must be seller\");\n    return doRelease(_tradeID, _seller, _buyer, _value, _fee);\n  }\n\n  uint16 constant GAS_doRelease = 3658;\n\n  function doRelease(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee\n  ) private returns (bool) {\n    Escrow memory _escrow;\n    bytes32 _tradeHash;\n    (_escrow, _tradeHash) = getEscrowAndHash(\n      _tradeID,\n      _seller,\n      _buyer,\n      _value,\n      _fee\n    );\n    if (!_escrow.exists) return false;\n    uint128 _gasFees = _escrow.relayerGasSpent +\n      (msg.sender == relayer ? GAS_doRelease * uint128(tx.gasprice) : 0);\n    delete escrows[_tradeHash];\n    emit Released(_tradeHash, _gasFees);\n    transferMinusFees(_escrow.tokenContract, _buyer, _value, _fee);\n    return true;\n  }\n\n  uint16 constant GAS_doResolveDispute = 14060;\n\n  function resolveDispute(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    uint8 _buyerPercent\n  ) external onlyArbitrator {\n    address _signature = recoverAddress(\n      keccak256(abi.encodePacked(_tradeID, RESOLVE_DISPUTE)),\n      _v,\n      _r,\n      _s\n    );\n    require(\n      _signature == _buyer || _signature == _seller,\n      \"Must be buyer or seller\"\n    );\n\n    Escrow memory _escrow;\n    bytes32 _tradeHash;\n    (_escrow, _tradeHash) = getEscrowAndHash(\n      _tradeID,\n      _seller,\n      _buyer,\n      _value,\n      _fee\n    );\n    require(_escrow.exists, \"Escrow does not exist\");\n    require(_buyerPercent <= 100, \"_buyerPercent must be 100 or lower\");\n\n    _escrow.relayerGasSpent += (GAS_doResolveDispute * uint128(tx.gasprice));\n\n    delete escrows[_tradeHash];\n    emit DisputeResolved(_tradeHash, _escrow.relayerGasSpent);\n    if (_buyerPercent > 0) {\n      // If dispute goes to buyer take the fee\n      uint256 _totalFees = ((_value * _fee) / 10000);\n      // Prevent underflow\n      uint256 buyerAmount = (_value * _buyerPercent) / 100 - _totalFees;\n      require(buyerAmount <= _value, \"Overflow error\");\n      collectedFees[_escrow.tokenContract] += _totalFees;\n\n      if (_escrow.tokenContract == 0x0000000000000000000000000000000000000000) {\n        _buyer.transfer(buyerAmount);\n      } else {\n        IERC20(_escrow.tokenContract).safeTransfer(_buyer, buyerAmount);\n      }\n    }\n    if (_buyerPercent < 100) {\n      uint256 sellerAmount = (_value * (100 - _buyerPercent)) / 100;\n      if (_escrow.tokenContract == 0x0000000000000000000000000000000000000000) {\n        _seller.transfer(sellerAmount);\n      } else {\n        IERC20(_escrow.tokenContract).safeTransfer(_seller, sellerAmount);\n      }\n    }\n  }\n\n  function buyerCancel(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee\n  ) external returns (bool) {\n    require(msg.sender == _buyer, \"Must be buyer\");\n    return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee);\n  }\n\n  function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\n    escrows[_tradeHash].relayerGasSpent += _gas * uint128(tx.gasprice);\n  }\n\n  uint16 constant GAS_doBuyerCancel = 2367;\n\n  function doBuyerCancel(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee\n  ) private returns (bool) {\n    Escrow memory _escrow;\n    bytes32 _tradeHash;\n    (_escrow, _tradeHash) = getEscrowAndHash(\n      _tradeID,\n      _seller,\n      _buyer,\n      _value,\n      _fee\n    );\n    require(_escrow.exists, \"Escrow does not exist\");\n    if (!_escrow.exists) {\n      return false;\n    }\n    uint128 _gasFees = _escrow.relayerGasSpent +\n      (msg.sender == relayer ? GAS_doBuyerCancel * uint128(tx.gasprice) : 0);\n    delete escrows[_tradeHash];\n    emit Cancelled(_tradeHash, _gasFees);\n    transferMinusFees(_escrow.tokenContract, _seller, _value, 0);\n    return true;\n  }\n\n  /***********************\n    +        Relays        +\n    ***********************/\n\n  uint16 constant GAS_batchRelayBaseCost = 30000;\n\n  function batchRelay(\n    bytes16[] memory _tradeID,\n    address payable[] memory _seller,\n    address payable[] memory _buyer,\n    uint256[] memory _value,\n    uint16[] memory _fee,\n    uint128[] memory _maximumGasPrice,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s,\n    uint8[] memory _instructionByte\n  ) public returns (bool[] memory) {\n    bool[] memory _results = new bool[](_tradeID.length);\n    for (uint8 i = 0; i < _tradeID.length; i++) {\n      _results[i] = relay(\n        _tradeID[i],\n        _seller[i],\n        _buyer[i],\n        _value[i],\n        _fee[i],\n        _maximumGasPrice[i],\n        _v[i],\n        _r[i],\n        _s[i],\n        _instructionByte[i]\n      );\n    }\n    return _results;\n  }\n\n  function relay(\n    bytes16 _tradeID,\n    address payable _seller,\n    address payable _buyer,\n    uint256 _value,\n    uint16 _fee,\n    uint128 _maximumGasPrice,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s,\n    uint8 _instructionByte\n  ) public returns (bool result) {\n    address _relayedSender = getRelayedSender(\n      _tradeID,\n      _instructionByte,\n      _maximumGasPrice,\n      _v,\n      _r,\n      _s\n    );\n    if (_relayedSender == _buyer) {\n      if (_instructionByte == BUYER_CANCELS) {\n        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee);\n      }\n    } else if (_relayedSender == _seller) {\n      if (_instructionByte == RELEASE_ESCROW) {\n        return doRelease(_tradeID, _seller, _buyer, _value, _fee);\n      }\n    } else {\n      require(msg.sender == _seller, \"Unrecognised party\");\n      return false;\n    }\n  }\n\n  /***********************\n    +      Management      +\n    ***********************/\n\n  function setArbitrator(address _newArbitrator) external onlyOwner {\n    arbitrator = _newArbitrator;\n  }\n\n  function setOwner(address _newOwner) external onlyOwner {\n    owner = _newOwner;\n  }\n\n  function setRelayer(address _newRelayer) external onlyOwner {\n    relayer = _newRelayer;\n  }\n\n  /***********************\n    +   Helper Functions   +\n    ***********************/\n\n  function transferMinusFees(\n    address _currency,\n    address payable _to,\n    uint256 _value,\n    uint16 _fee\n  ) private {\n    uint256 _totalFees = ((_value * _fee) / 10000);\n\n    // Add fees to the pot for localcoinswap to withdraw\n    collectedFees[_currency] += _totalFees;\n    IERC20(_currency).safeTransfer(_to, _value - _totalFees);\n  }\n\n  function withdrawFees(\n    address payable _to,\n    address _currency,\n    uint256 _amount\n  ) external onlyOwner {\n    // This check also prevents underflow\n    require(\n      _amount <= collectedFees[_currency],\n      \"Amount is higher than amount available\"\n    );\n    collectedFees[_currency] -= _amount;\n    IERC20(_currency).safeTransfer(_to, _amount);\n  }\n\n  function getEscrowAndHash(\n    bytes16 _tradeID,\n    address _seller,\n    address _buyer,\n    uint256 _value,\n    uint16 _fee\n  ) private view returns (Escrow storage, bytes32) {\n    bytes32 _tradeHash = keccak256(\n      abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee)\n    );\n    return (escrows[_tradeHash], _tradeHash);\n  }\n\n  function recoverAddress(\n    bytes32 _h,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) private pure returns (address) {\n    bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\n    return ecrecover(_prefixedHash, _v, _r, _s);\n  }\n\n  function getRelayedSender(\n    bytes16 _tradeID,\n    uint8 _instructionByte,\n    uint128 _maximumGasPrice,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) private view returns (address) {\n    bytes32 _hash = keccak256(\n      abi.encodePacked(_tradeID, _instructionByte, _maximumGasPrice)\n    );\n    require(\n      tx.gasprice < _maximumGasPrice,\n      \"Gas price is higher than maximum gas price\"\n    );\n    return recoverAddress(_hash, _v, _r, _s);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only the owner can do this\");\n    _;\n  }\n\n  modifier onlyArbitrator() {\n    require(msg.sender == arbitrator, \"Only the arbitrator can do this\");\n    _;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}